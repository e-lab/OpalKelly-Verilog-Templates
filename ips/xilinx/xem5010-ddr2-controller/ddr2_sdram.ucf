############################################################################
## 
##  Xilinx, Inc. 2006            www.xilinx.com 
##  Mon May 11 11:34:28 2009
##  Generated by MIG Version 2.3
##  
############################################################################
##  File name :       ddr2_sdram.ucf
## 
##  Details :     Constraints file
##                    FPGA family:       virtex5
##                    FPGA:              xc5vlx50-ff676
##                    Speedgrade:        -1
##                    Design Entry:      VERILOG
##                    Frequency:         266.66 MHz
##                    Design:            with Test bench
##                    DCM Used:          Enable
##                    Two Bytes per Bank:Disable
##                    No.Of Controllers: 2
##
############################################################################ 

############################################################################
# Clock constraints                                                        #
############################################################################

NET "u_ddr2_infrastructure/sys_clk_ibufg" TNM_NET =  "SYS_CLK";
TIMESPEC "TS_SYS_CLK" = PERIOD "SYS_CLK" 3.75 ns HIGH 50 %;

NET "u_ddr2_infrastructure/clk200_ibufg" TNM_NET = "SYS_CLK_200";
TIMESPEC "TS_SYS_CLK_200" = PERIOD "SYS_CLK_200" 5 ns HIGH 50 %;

############################################################################
########################################################################
# Controller 0
# Memory Device: DDR2_SDRAM->Components->MT47H32M16XX-3 #
# Supported Part Numbers: MT47H32M16BN-3;MT47H32M16CC-3;MT47H32M16FN-3;MT47H32M16GC-3

# Data Width:     16 #
# Data Mask:     1 #
########################################################################

################################################################################
# I/O STANDARDS
################################################################################

NET  "c0_ddr2_dq[*]"                            IOSTANDARD = SSTL18_II_DCI;
NET  "c0_ddr2_a[*]"                             IOSTANDARD = SSTL18_II_DCI;
NET  "c0_ddr2_ba[*]"                            IOSTANDARD = SSTL18_II_DCI;
NET  "c0_ddr2_ras_n"                            IOSTANDARD = SSTL18_II_DCI;
NET  "c0_ddr2_cas_n"                            IOSTANDARD = SSTL18_II_DCI;
NET  "c0_ddr2_we_n"                             IOSTANDARD = SSTL18_II_DCI;
NET  "c0_ddr2_cs_n[*]"                          IOSTANDARD = SSTL18_II_DCI;
NET  "c0_ddr2_odt[*]"                           IOSTANDARD = SSTL18_II_DCI;
NET  "c0_ddr2_cke[*]"                           IOSTANDARD = SSTL18_II_DCI;
NET  "c0_ddr2_dm[*]"                            IOSTANDARD = SSTL18_II_DCI;
NET  "sys_clk_p"                                IOSTANDARD = LVPECL_25;
NET  "sys_clk_n"                                IOSTANDARD = LVPECL_25;
NET  "clk200_p"                                 IOSTANDARD = LVPECL_25;
NET  "clk200_n"                                 IOSTANDARD = LVPECL_25;
NET  "sys_rst_n"                                IOSTANDARD = LVCMOS18;
NET  "c0_phy_init_done"                         IOSTANDARD = LVCMOS18;
NET  "c0_error"                                 IOSTANDARD = LVCMOS18;
NET  "c0_ddr2_dqs[*]"                           IOSTANDARD = DIFF_SSTL18_II_DCI;
NET  "c0_ddr2_dqs_n[*]"                         IOSTANDARD = DIFF_SSTL18_II_DCI;
NET  "c0_ddr2_ck[*]"                            IOSTANDARD = DIFF_SSTL18_II_DCI;
NET  "c0_ddr2_ck_n[*]"                          IOSTANDARD = DIFF_SSTL18_II_DCI;

################################################################################
# Location Constraints
################################################################################

NET  "c0_ddr2_dq[0]"                             LOC = "D11" ;	      #Bank 16
NET  "c0_ddr2_dq[1]"                             LOC = "D10" ;	      #Bank 16
NET  "c0_ddr2_dq[2]"                             LOC = "C11" ;	      #Bank 16
NET  "c0_ddr2_dq[3]"                             LOC = "C12" ;	      #Bank 16
NET  "c0_ddr2_dq[4]"                             LOC = "B12" ;	      #Bank 16
NET  "c0_ddr2_dq[5]"                             LOC = "A13" ;	      #Bank 16
NET  "c0_ddr2_dq[6]"                             LOC = "A12" ;	      #Bank 16
NET  "c0_ddr2_dq[7]"                             LOC = "C9" ;	      #Bank 16
NET  "c0_ddr2_dq[8]"                             LOC = "B9" ;	      #Bank 16
NET  "c0_ddr2_dq[9]"                             LOC = "B10" ;	      #Bank 16
NET  "c0_ddr2_dq[10]"                            LOC = "B11" ;	      #Bank 16
NET  "c0_ddr2_dq[11]"                            LOC = "A10" ;	      #Bank 16
NET  "c0_ddr2_dq[12]"                            LOC = "A8" ;	      #Bank 16
NET  "c0_ddr2_dq[13]"                            LOC = "B5" ;	      #Bank 16
NET  "c0_ddr2_dq[14]"                            LOC = "B6" ;	      #Bank 16
NET  "c0_ddr2_dq[15]"                            LOC = "D3" ;	      #Bank 16
NET  "c0_ddr2_a[12]"                             LOC = "C6" ;	      #Bank 16
NET  "c0_ddr2_a[11]"                             LOC = "C7" ;	      #Bank 16
NET  "c0_ddr2_a[10]"                             LOC = "C4" ;	      #Bank 16
NET  "c0_ddr2_a[9]"                              LOC = "B4" ;	      #Bank 16
NET  "c0_ddr2_a[8]"                              LOC = "C2" ;	      #Bank 16
NET  "c0_ddr2_a[7]"                              LOC = "C3" ;	      #Bank 16
NET  "c0_ddr2_a[6]"                              LOC = "A2" ;	      #Bank 16
NET  "c0_ddr2_a[5]"                              LOC = "A3" ;	      #Bank 16
NET  "c0_ddr2_a[4]"                              LOC = "D1" ;	      #Bank 16
NET  "c0_ddr2_a[3]"                              LOC = "C1" ;	      #Bank 16
NET  "c0_ddr2_a[2]"                              LOC = "B1" ;	      #Bank 16
NET  "c0_ddr2_a[1]"                              LOC = "B2" ;	      #Bank 16
NET  "c0_ddr2_a[0]"                              LOC = "E7" ;	      #Bank 12
NET  "c0_ddr2_ba[1]"                             LOC = "F7" ;	      #Bank 12
NET  "c0_ddr2_ba[0]"                             LOC = "E6" ;	      #Bank 12
NET  "c0_ddr2_ras_n"                             LOC = "E5" ;	      #Bank 12
NET  "c0_ddr2_cas_n"                             LOC = "G6" ;	      #Bank 12
NET  "c0_ddr2_we_n"                              LOC = "G7" ;	      #Bank 12
NET  "c0_ddr2_cs_n[0]"                           LOC = "F5" ;	      #Bank 12
NET  "c0_ddr2_odt[0]"                            LOC = "F4" ;	      #Bank 12
NET  "c0_ddr2_cke[0]"                            LOC = "J6" ;	      #Bank 12
NET  "c0_ddr2_dm[0]"                             LOC = "C13" ;	      #Bank 16
NET  "c0_ddr2_dm[1]"                             LOC = "A9" ;	      #Bank 16
NET  "sys_clk_p"                                 LOC = "AD18" ;	      #Bank 4
NET  "sys_clk_n"                                 LOC = "AC18" ;	      #Bank 4
NET  "clk200_p"                                  LOC = "AB10" ;	      #Bank 4
NET  "clk200_n"                                  LOC = "AB9" ;	      #Bank 4
NET  "sys_rst_n"                                 LOC = "H6" ;	      #Bank 12
NET  "c0_phy_init_done"                          LOC = "G5" ;	      #Bank 12
NET  "c0_error"                                  LOC = "H4" ;	      #Bank 12
NET  "c0_ddr2_dqs[0]"                            LOC = "D8" ;	      #Bank 16
NET  "c0_ddr2_dqs_n[0]"                          LOC = "C8" ;	      #Bank 16
NET  "c0_ddr2_dqs[1]"                            LOC = "B7" ;	      #Bank 16
NET  "c0_ddr2_dqs_n[1]"                          LOC = "A7" ;	      #Bank 16
NET  "c0_ddr2_ck[0]"                             LOC = "D5" ;	      #Bank 16
NET  "c0_ddr2_ck_n[0]"                           LOC = "D6" ;	      #Bank 16

################################################################################
#IDELAYCTRL Location Constraints
################################################################################
INST "*/IDELAYCTRL_INST[0].u_idelayctrl" LOC=IDELAYCTRL_X2Y4;

###############################################################################
# Define multicycle paths - these paths may take longer because additional
# time allowed for logic to settle in calibration/initialization FSM
###############################################################################

# MIG 2.1: Eliminate Timegroup definitions for CLK0, and CLK90. Instead trace
#          multicycle paths from originating flip-flop to ANY destination
#          flip-flop (or in some cases, it can also be a BRAM)
# MUX Select for either rising/falling CLK0 for 2nd stage read capture
INST "u_ddr2_top_0/*/u_phy_calib/gen_rd_data_sel*.u_ff_rd_data_sel" TNM = "TNM_RD_DATA_SEL_C0";
TIMESPEC "TS_MC_RD_DATA_SEL_C0" = FROM "TNM_RD_DATA_SEL_C0" TO FFS
"TS_SYS_CLK" * 4;
# MUX select for read data - optional delay on data to account for byte skews
INST "u_ddr2_top_0/*/u_usr_rd/gen_rden_sel_mux*.u_ff_rden_sel_mux" TNM = "TNM_RDEN_SEL_MUX_C0";
TIMESPEC "TS_MC_RDEN_SEL_MUX_C0" = FROM "TNM_RDEN_SEL_MUX_C0" TO FFS
"TS_SYS_CLK" * 4;
# Calibration/Initialization complete status flag (for PHY logic only) - can
# be used to drive both flip-flops and BRAMs
INST "u_ddr2_top_0/*/u_phy_init/u_ff_phy_init_data_sel" TNM = "TNM_PHY_INIT_DATA_SEL_C0";
TIMESPEC "TS_MC_PHY_INIT_DATA_SEL_0_C0" = FROM "TNM_PHY_INIT_DATA_SEL_C0" TO FFS
"TS_SYS_CLK" * 4;
TIMESPEC "TS_MC_PHY_INIT_DATA_SEL_90_C0" = FROM "TNM_PHY_INIT_DATA_SEL_C0" TO RAMS
"TS_SYS_CLK" * 4;
# Select (address) bits for SRL32 shift registers used in stage3/stage4
# calibration
INST "u_ddr2_top_0/*/u_phy_calib/gen_gate_dly*.u_ff_gate_dly" TNM = "TNM_GATE_DLY_C0";
TIMESPEC "TS_MC_GATE_DLY_C0" = FROM "TNM_GATE_DLY_C0" TO FFS "TS_SYS_CLK" * 4;
INST "u_ddr2_top_0/*/u_phy_calib/gen_rden_dly*.u_ff_rden_dly" TNM = "TNM_RDEN_DLY_C0";
TIMESPEC "TS_MC_RDEN_DLY_C0" = FROM "TNM_RDEN_DLY_C0" TO FFS "TS_SYS_CLK" * 4;
INST "u_ddr2_top_0/*/u_phy_calib/gen_cal_rden_dly*.u_ff_cal_rden_dly"
  TNM = "TNM_CAL_RDEN_DLY_C0";
TIMESPEC "TS_MC_CAL_RDEN_DLY_C0" = FROM "TNM_CAL_RDEN_DLY_C0" TO FFS
  "TS_SYS_CLK" * 4;

###############################################################################
# DQS Read Post amble Glitch Squelch circuit related constraints
###############################################################################

###############################################################################
# LOC placement of DQS-squelch related IDDR and IDELAY elements
# Each circuit can be located at any of the following locations:
#  1. Unused "N"-side of DQS differential pair I/O
#  2. DM data mask (output only, input side is free for use)
#  3. Any output-only site
###############################################################################

INST "u_ddr2_top_0/*/gen_dqs[0].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X2Y182";
INST "u_ddr2_top_0/*/gen_dqs[0].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X2Y182";
INST "u_ddr2_top_0/*/gen_dqs[1].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X2Y180";
INST "u_ddr2_top_0/*/gen_dqs[1].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X2Y180";

###############################################################################
# LOC and timing constraints for flop driving DQS CE enable signal
# from fabric logic. Even though the absolute delay on this path is
# calibrated out (when synchronizing this output to DQS), the delay
# should still be kept as low as possible to reduce post-calibration
# voltage/temp variations - these are roughly proportional to the
# absolute delay of the path
###############################################################################

INST "u_ddr2_top_0/*/u_phy_calib/gen_gate[0].u_en_dqs_ff"  LOC = SLICE_X51Y91;
INST "u_ddr2_top_0/*/u_phy_calib/gen_gate[1].u_en_dqs_ff"  LOC = SLICE_X51Y90;

# Control for DQS gate - from fabric flop. Prevent "runaway" delay -
# two parts to this path: (1) from fabric flop to IDELAY, (2) from
# IDELAY to asynchronous reset of IDDR that drives the DQ CE's
# This can be relaxed by the user for lower frequencies:
# 300MHz = 850ps, 267MHz = 900ps. At 200MHz = 950ps.
# In general PAR should be able to route this
# within 900ps over all speed grades.
NET "u_ddr2_top_0/*/u_phy_io/en_dqs*" MAXDELAY = 600 ps;
NET "u_ddr2_top_0/*/u_phy_io/gen_dqs*.u_iob_dqs/en_dqs_sync" MAXDELAY = 850 ps;

###############################################################################
# "Half-cycle" path constraint from IDDR to CE pin for all DQ IDDR's
# for DQS Read Post amble Glitch Squelch circuit
###############################################################################

# Max delay from output of IDDR to CE input of DQ IDDRs = tRPST + some slack
#  where slack account for rise-time of DQS on board. For now assume slack = 
#  0.400ns (based on initial SPICE simulations, assumes use of ODT), so 
#  time = 0.4*Tcyc + 0.40ns = 1.6ns @333MHz
INST "u_ddr2_top_0/*/gen_dqs[*].u_iob_dqs/u_iddr_dq_ce" TNM = "TNM_DQ_CE_IDDR_C0";
INST "u_ddr2_top_0/*/gen_dq[*].u_iob_dq/gen_stg2_*.u_iddr_dq" TNM = "TNM_DQS_FLOPS_C0";
TIMESPEC "TS_DQ_CE_C0" = FROM "TNM_DQ_CE_IDDR_C0" TO "TNM_DQS_FLOPS_C0" 1.9 ns;

###############################################################################
# MIG 2.2: Prevent unrelated logic from being packed into any slices used
#          by read data capture RPM's - if unrelated logic gets packed into
#          these slices, it could cause the DIRT strings that define the
#          IDDR -> fabric flop routing to become unroutable during PAR stage
#          (unrelated logic may require routing resources required by the
#          DIRT strings - MAP does not currently take into account DIRT
#          strings when placing logic
###############################################################################

AREA_GROUP "DDR_CAPTURE_FFS" GROUP = CLOSED;

###############################################################################
# Location constraints for DQ read-data capture flops in fabric (for 2nd
# stage capture)
###############################################################################

INST "u_ddr2_top_0/*/gen_dq[0].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X48Y99;
INST "u_ddr2_top_0/*/gen_dq[1].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X48Y99;
INST "u_ddr2_top_0/*/gen_dq[2].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X48Y98;
INST "u_ddr2_top_0/*/gen_dq[3].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X48Y98;
INST "u_ddr2_top_0/*/gen_dq[4].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X48Y97;
INST "u_ddr2_top_0/*/gen_dq[5].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X48Y96;
INST "u_ddr2_top_0/*/gen_dq[6].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X48Y96;
INST "u_ddr2_top_0/*/gen_dq[7].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X48Y95;
INST "u_ddr2_top_0/*/gen_dq[8].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X48Y94;
INST "u_ddr2_top_0/*/gen_dq[9].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X48Y94;
INST "u_ddr2_top_0/*/gen_dq[10].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X48Y93;
INST "u_ddr2_top_0/*/gen_dq[11].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X48Y93;
INST "u_ddr2_top_0/*/gen_dq[12].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X48Y92;
INST "u_ddr2_top_0/*/gen_dq[13].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X48Y86;
INST "u_ddr2_top_0/*/gen_dq[14].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X48Y86;
INST "u_ddr2_top_0/*/gen_dq[15].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X48Y85;

########################################################################
# Controller 1
# Memory Device: DDR2_SDRAM->Components->MT47H32M16XX-3 #
# Supported Part Numbers: MT47H32M16BN-3;MT47H32M16CC-3;MT47H32M16FN-3;MT47H32M16GC-3

# Data Width:     16 #
# Data Mask:     1 #
########################################################################

################################################################################
# I/O STANDARDS
################################################################################

NET  "c1_ddr2_dq[*]"                            IOSTANDARD = SSTL18_II_DCI;
NET  "c1_ddr2_a[*]"                             IOSTANDARD = SSTL18_II_DCI;
NET  "c1_ddr2_ba[*]"                            IOSTANDARD = SSTL18_II_DCI;
NET  "c1_ddr2_ras_n"                            IOSTANDARD = SSTL18_II_DCI;
NET  "c1_ddr2_cas_n"                            IOSTANDARD = SSTL18_II_DCI;
NET  "c1_ddr2_we_n"                             IOSTANDARD = SSTL18_II_DCI;
NET  "c1_ddr2_cs_n[*]"                          IOSTANDARD = SSTL18_II_DCI;
NET  "c1_ddr2_odt[*]"                           IOSTANDARD = SSTL18_II_DCI;
NET  "c1_ddr2_cke[*]"                           IOSTANDARD = SSTL18_II_DCI;
NET  "c1_ddr2_dm[*]"                            IOSTANDARD = SSTL18_II_DCI;
NET  "c1_phy_init_done"                         IOSTANDARD = LVCMOS18;
NET  "c1_error"                                 IOSTANDARD = LVCMOS18;
NET  "c1_ddr2_dqs[*]"                           IOSTANDARD = DIFF_SSTL18_II_DCI;
NET  "c1_ddr2_dqs_n[*]"                         IOSTANDARD = DIFF_SSTL18_II_DCI;
NET  "c1_ddr2_ck[*]"                            IOSTANDARD = DIFF_SSTL18_II_DCI;
NET  "c1_ddr2_ck_n[*]"                          IOSTANDARD = DIFF_SSTL18_II_DCI;

################################################################################
# Location Constraints
################################################################################

NET  "c1_ddr2_dq[0]"                             LOC = "C14" ;	      #Bank 15
NET  "c1_ddr2_dq[1]"                             LOC = "B14" ;	      #Bank 15
NET  "c1_ddr2_dq[2]"                             LOC = "A14" ;	      #Bank 15
NET  "c1_ddr2_dq[3]"                             LOC = "A15" ;	      #Bank 15
NET  "c1_ddr2_dq[4]"                             LOC = "B16" ;	      #Bank 15
NET  "c1_ddr2_dq[5]"                             LOC = "D16" ;	      #Bank 15
NET  "c1_ddr2_dq[6]"                             LOC = "C16" ;	      #Bank 15
NET  "c1_ddr2_dq[7]"                             LOC = "D18" ;	      #Bank 15
NET  "c1_ddr2_dq[8]"                             LOC = "B17" ;	      #Bank 15
NET  "c1_ddr2_dq[9]"                             LOC = "A17" ;	      #Bank 15
NET  "c1_ddr2_dq[10]"                            LOC = "A18" ;	      #Bank 15
NET  "c1_ddr2_dq[11]"                            LOC = "A19" ;	      #Bank 15
NET  "c1_ddr2_dq[12]"                            LOC = "C18" ;	      #Bank 15
NET  "c1_ddr2_dq[13]"                            LOC = "B22" ;	      #Bank 15
NET  "c1_ddr2_dq[14]"                            LOC = "A22" ;	      #Bank 15
NET  "c1_ddr2_dq[15]"                            LOC = "A23" ;	      #Bank 15
NET  "c1_ddr2_a[12]"                             LOC = "C21" ;	      #Bank 15
NET  "c1_ddr2_a[11]"                             LOC = "B21" ;	      #Bank 15
NET  "c1_ddr2_a[10]"                             LOC = "B24" ;	      #Bank 15
NET  "c1_ddr2_a[9]"                              LOC = "C23" ;	      #Bank 15
NET  "c1_ddr2_a[8]"                              LOC = "D24" ;	      #Bank 15
NET  "c1_ddr2_a[7]"                              LOC = "C24" ;	      #Bank 15
NET  "c1_ddr2_a[6]"                              LOC = "B25" ;	      #Bank 15
NET  "c1_ddr2_a[5]"                              LOC = "A25" ;	      #Bank 15
NET  "c1_ddr2_a[4]"                              LOC = "B26" ;	      #Bank 15
NET  "c1_ddr2_a[3]"                              LOC = "C26" ;	      #Bank 15
NET  "c1_ddr2_a[2]"                              LOC = "D26" ;	      #Bank 15
NET  "c1_ddr2_a[1]"                              LOC = "D25" ;	      #Bank 15
NET  "c1_ddr2_a[0]"                              LOC = "G20" ;	      #Bank 11
NET  "c1_ddr2_ba[1]"                             LOC = "F20" ;	      #Bank 11
NET  "c1_ddr2_ba[0]"                             LOC = "E21" ;	      #Bank 11
NET  "c1_ddr2_ras_n"                             LOC = "E20" ;	      #Bank 11
NET  "c1_ddr2_cas_n"                             LOC = "E22" ;	      #Bank 11
NET  "c1_ddr2_we_n"                              LOC = "E23" ;	      #Bank 11
NET  "c1_ddr2_cs_n[0]"                           LOC = "F22" ;	      #Bank 11
NET  "c1_ddr2_odt[0]"                            LOC = "F23" ;	      #Bank 11
NET  "c1_ddr2_cke[0]"                            LOC = "G21" ;	      #Bank 11
NET  "c1_ddr2_dm[0]"                             LOC = "B15" ;	      #Bank 15
NET  "c1_ddr2_dm[1]"                             LOC = "B19" ;	      #Bank 15
NET  "c1_phy_init_done"                          LOC = "H21" ;	      #Bank 11
NET  "c1_error"                                  LOC = "H22" ;	      #Bank 11
NET  "c1_ddr2_dqs[0]"                            LOC = "A20" ;	      #Bank 15
NET  "c1_ddr2_dqs_n[0]"                          LOC = "B20" ;	      #Bank 15
NET  "c1_ddr2_dqs[1]"                            LOC = "C19" ;	      #Bank 15
NET  "c1_ddr2_dqs_n[1]"                          LOC = "D19" ;	      #Bank 15
NET  "c1_ddr2_ck[0]"                             LOC = "D21" ;	      #Bank 15
NET  "c1_ddr2_ck_n[0]"                           LOC = "D20" ;	      #Bank 15

################################################################################
#IDELAYCTRL Location Constraints
################################################################################
INST "*/IDELAYCTRL_INST[1].u_idelayctrl" LOC=IDELAYCTRL_X0Y4;

###############################################################################
# Define multicycle paths - these paths may take longer because additional
# time allowed for logic to settle in calibration/initialization FSM
###############################################################################

# MIG 2.1: Eliminate Timegroup definitions for CLK0, and CLK90. Instead trace
#          multicycle paths from originating flip-flop to ANY destination
#          flip-flop (or in some cases, it can also be a BRAM)
# MUX Select for either rising/falling CLK0 for 2nd stage read capture
INST "u_ddr2_top_1/*/u_phy_calib/gen_rd_data_sel*.u_ff_rd_data_sel" TNM = "TNM_RD_DATA_SEL_C1";
TIMESPEC "TS_MC_RD_DATA_SEL_C1" = FROM "TNM_RD_DATA_SEL_C1" TO FFS
"TS_SYS_CLK" * 4;
# MUX select for read data - optional delay on data to account for byte skews
INST "u_ddr2_top_1/*/u_usr_rd/gen_rden_sel_mux*.u_ff_rden_sel_mux" TNM = "TNM_RDEN_SEL_MUX_C1";
TIMESPEC "TS_MC_RDEN_SEL_MUX_C1" = FROM "TNM_RDEN_SEL_MUX_C1" TO FFS
"TS_SYS_CLK" * 4;
# Calibration/Initialization complete status flag (for PHY logic only) - can
# be used to drive both flip-flops and BRAMs
INST "u_ddr2_top_1/*/u_phy_init/u_ff_phy_init_data_sel" TNM = "TNM_PHY_INIT_DATA_SEL_C1";
TIMESPEC "TS_MC_PHY_INIT_DATA_SEL_0_C1" = FROM "TNM_PHY_INIT_DATA_SEL_C1" TO FFS
"TS_SYS_CLK" * 4;
TIMESPEC "TS_MC_PHY_INIT_DATA_SEL_90_C1" = FROM "TNM_PHY_INIT_DATA_SEL_C1" TO RAMS
"TS_SYS_CLK" * 4;
# Select (address) bits for SRL32 shift registers used in stage3/stage4
# calibration
INST "u_ddr2_top_1/*/u_phy_calib/gen_gate_dly*.u_ff_gate_dly" TNM = "TNM_GATE_DLY_C1";
TIMESPEC "TS_MC_GATE_DLY_C1" = FROM "TNM_GATE_DLY_C1" TO FFS "TS_SYS_CLK" * 4;
INST "u_ddr2_top_1/*/u_phy_calib/gen_rden_dly*.u_ff_rden_dly" TNM = "TNM_RDEN_DLY_C1";
TIMESPEC "TS_MC_RDEN_DLY_C1" = FROM "TNM_RDEN_DLY_C1" TO FFS "TS_SYS_CLK" * 4;
INST "u_ddr2_top_1/*/u_phy_calib/gen_cal_rden_dly*.u_ff_cal_rden_dly"
  TNM = "TNM_CAL_RDEN_DLY_C1";
TIMESPEC "TS_MC_CAL_RDEN_DLY_C1" = FROM "TNM_CAL_RDEN_DLY_C1" TO FFS
  "TS_SYS_CLK" * 4;

###############################################################################
# DQS Read Post amble Glitch Squelch circuit related constraints
###############################################################################

###############################################################################
# LOC placement of DQS-squelch related IDDR and IDELAY elements
# Each circuit can be located at any of the following locations:
#  1. Unused "N"-side of DQS differential pair I/O
#  2. DM data mask (output only, input side is free for use)
#  3. Any output-only site
###############################################################################

INST "u_ddr2_top_1/*/gen_dqs[0].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y182";
INST "u_ddr2_top_1/*/gen_dqs[0].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y182";
INST "u_ddr2_top_1/*/gen_dqs[1].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y180";
INST "u_ddr2_top_1/*/gen_dqs[1].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y180";

###############################################################################
# LOC and timing constraints for flop driving DQS CE enable signal
# from fabric logic. Even though the absolute delay on this path is
# calibrated out (when synchronizing this output to DQS), the delay
# should still be kept as low as possible to reduce post-calibration
# voltage/temp variations - these are roughly proportional to the
# absolute delay of the path
###############################################################################

INST "u_ddr2_top_1/*/u_phy_calib/gen_gate[0].u_en_dqs_ff"  LOC = SLICE_X0Y91;
INST "u_ddr2_top_1/*/u_phy_calib/gen_gate[1].u_en_dqs_ff"  LOC = SLICE_X0Y90;

# Control for DQS gate - from fabric flop. Prevent "runaway" delay -
# two parts to this path: (1) from fabric flop to IDELAY, (2) from
# IDELAY to asynchronous reset of IDDR that drives the DQ CE's
# This can be relaxed by the user for lower frequencies:
# 300MHz = 850ps, 267MHz = 900ps. At 200MHz = 950ps.
# In general PAR should be able to route this
# within 900ps over all speed grades.
NET "u_ddr2_top_1/*/u_phy_io/en_dqs*" MAXDELAY = 600 ps;
NET "u_ddr2_top_1/*/u_phy_io/gen_dqs*.u_iob_dqs/en_dqs_sync" MAXDELAY = 850 ps;

###############################################################################
# "Half-cycle" path constraint from IDDR to CE pin for all DQ IDDR's
# for DQS Read Post amble Glitch Squelch circuit
###############################################################################

# Max delay from output of IDDR to CE input of DQ IDDRs = tRPST + some slack
#  where slack account for rise-time of DQS on board. For now assume slack = 
#  0.400ns (based on initial SPICE simulations, assumes use of ODT), so 
#  time = 0.4*Tcyc + 0.40ns = 1.6ns @333MHz
INST "u_ddr2_top_1/*/gen_dqs[*].u_iob_dqs/u_iddr_dq_ce" TNM = "TNM_DQ_CE_IDDR_C1";
INST "u_ddr2_top_1/*/gen_dq[*].u_iob_dq/gen_stg2_*.u_iddr_dq" TNM = "TNM_DQS_FLOPS_C1";
TIMESPEC "TS_DQ_CE_C1" = FROM "TNM_DQ_CE_IDDR_C1" TO "TNM_DQS_FLOPS_C1" 1.9 ns;

###############################################################################
# Location constraints for DQ read-data capture flops in fabric (for 2nd
# stage capture)
###############################################################################

INST "u_ddr2_top_1/*/gen_dq[0].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X0Y99;
INST "u_ddr2_top_1/*/gen_dq[1].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X0Y99;
INST "u_ddr2_top_1/*/gen_dq[2].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X0Y98;
INST "u_ddr2_top_1/*/gen_dq[3].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X0Y98;
INST "u_ddr2_top_1/*/gen_dq[4].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X0Y97;
INST "u_ddr2_top_1/*/gen_dq[5].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X0Y96;
INST "u_ddr2_top_1/*/gen_dq[6].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X0Y96;
INST "u_ddr2_top_1/*/gen_dq[7].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X0Y95;
INST "u_ddr2_top_1/*/gen_dq[8].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X0Y94;
INST "u_ddr2_top_1/*/gen_dq[9].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X0Y94;
INST "u_ddr2_top_1/*/gen_dq[10].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X0Y93;
INST "u_ddr2_top_1/*/gen_dq[11].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X0Y93;
INST "u_ddr2_top_1/*/gen_dq[12].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X0Y92;
INST "u_ddr2_top_1/*/gen_dq[13].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X0Y86;
INST "u_ddr2_top_1/*/gen_dq[14].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X0Y86;
INST "u_ddr2_top_1/*/gen_dq[15].u_iob_dq/gen_stg2_*.u_ff_stg2a_rise"  RLOC_ORIGIN = X0Y85;

